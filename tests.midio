type User {
	name: Text
	email: Email
	age: Number
}

context Authenticated {
	current_user: User
}

declare previous_unique_month(Month): Month

let previousMonth = previous_unique_month(unique_month(current_user))

// Only impure functions are allowed to use other impure functions or use contexts
impure startNewSubscriptionPeriod {
	requires_context Authenticated
	input subscription: Subscription
	input usage: DataUsagePeriod

	let dlf = dataLeftOver(subscription, usage)
	SubscriptionPeriod(CREATE, dlf, current_user)
}

// An interface implicitly implemented for all types that are Entities
implicit interface Store of T where T is Entity {
	impure! // the impure! statement states that this interface makes the implementer impure
	type Action {
		GET, SET, DELETE
	}
	comptime input action: Action
	switch (action) {
		GET {
			input fieldsOf(T)
			output result: T or [T]
		}
		SET {
			input key: keysOf(T)
			input newValue: T
		}
		DELETE {
			input key: keysOf(T)
		}
	}
}

startNewSubscriptionPeriod(
	subscription: SubscriptionPeriod(GET, previousMonth, current_user)
	usage: DataUsagePeriod(GET, previousMonth, current_user)
)

// dataLeftOver is a pure function, and thus cannot access impure functions or any context
pure dataLeftOver {
	input sub: Subscription
	input usage: DataUsagePeriod

	output result: Number

	result = lowest((sub.includedData + sub.rolledOverData) - usage.usage)
}

// ============== BRANCHING ===================

type Direction {
	North, East, South, West
}

pure getDirection {
	input angle: NumberRange(0, 360)
	output result: Direction
	if angle >= 0 and angle < 90 {
		result = North
	} else if angle >= 90 and angle < 180 {
		result = East
	} else if angle >= 180 and angle < 270 {
		result = South
	} else {
		result = West
	}
}

switch getDirection(123) {
	North {
		...
	}
	East {
		...
	}
	South {
		...
	}
	West {
		...
	}
}

// ========== ERROR HANDLING ==============

// Calling GET on a type without any further inputs returns all instances of that type
// the type here is User(GET) -> Result<[User], Error>
case User(GET) {
	// First item specifies the matched variant, and the second a name which its content is bound to.
	Ok users {
		// users here contains the list of all users
	}
	Err error {
		// error contains an error type with additional information about what whent wrong.
	}
}

// Implicitly combining errors
getUsersAndSubscriptions {
	output users: [User]
	output subscriptions: [Subscription]

	users = User(GET)
	subscriptions = Subscription(GET)

	// Since User and Subscription can return an error, getUsersAndSubscriptions type will actually
	// become () -> Result<(users: [User], subscriptions: [Subscrioption]), Error>
}
