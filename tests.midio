type User {
	name: Text
	email: Email
	age: Number
}

context Authenticated {
	current_user: User
}

declare previous_unique_month(Month): Month

let previousMonth = previous_unique_month(unique_month(current_user))

// Only impure functions are allowed to use other impure functions or use contexts
impure startNewSubscriptionPeriod {
	requires_context Authenticated
	input subscription: Subscription
	input usage: DataUsagePeriod

	let dlf <- dataLeftOver(subscription, usage)
	SubscriptionPeriod(CREATE, dlf, current_user)
}

// An interface implicitly implemented for all types that are Entities
implicit interface Store of T where T is Entity {
	impure! // the impure! statement states that this interface makes the implementer impure
	type Action {
		GET, SET, DELETE
	}

	comptime input action: Action
	switch (action) {
		GET {
			input fieldsOf(T)

			// We need to infer if this is a T or [T] somehow
			// The simplest option would be to have them as separate operations
			output result: T or [T]
		}
		SET {
			input key: keysOf(T)
			input newValue: T
		}
		DELETE {
			input key: keysOf(T)
		}
	}
}

startNewSubscriptionPeriod(
	subscription: SubscriptionPeriod(GET, previousMonth, current_user)
	usage: DataUsagePeriod(GET, previousMonth, current_user)
)

// ======
// Same as the above, but each store operation is a separate function.
// We can still represent these differently in the UI.
// ======

// Read operations:

get(E: Entity) {
	input key: Key(E)
	output result: Result(Maybe(E), GetError)
}

// How do we represent filters?
// How would you build a dynamic filter UI?
filter(E: Entity, F: Filter(E)) {
	input filter: Filter(E)
	output result: Result(List(E), FilterError)
}

// Write operations:

// Error if entity already exists
create(E: Entity) {
	input entity: E
	output result: Result(E, InsertError)
}

// Error if entity does not already exist
update(E: Entity) {
	input entity: E
	output result: Result(E, UpdateError)
}

// Create entity, or update if already exists
createOrUpdate(E: Entity) {
	input entity: E
	output result: Result(E, CreateOrUpdateError)
}

startNewSubscriptionPeriod {
	let key <- (previousMonth, current_user)
	subscription <- get(SubscriptionPeriod) { key <- key }
	usage        <- get(DataUsagePeriod)    { key <- key }
}

// dataLeftOver is a pure function, and thus cannot access impure functions or any context
pure dataLeftOver {
	input sub: Subscription
	input usage: DataUsagePeriod

	output result: Number

	result <- lowest((sub.includedData + sub.rolledOverData) - usage.usage)
}

// ======== operators =============

sink <- source : binding operator
source -> sink : inverted binding operator
sink << value : push operator
value >> sink : inverted push operator

// ============== BRANCHING ===================


type Direction {
	North, East, South, West
}

pure getDirection {
	input angle: NumberRange(0, 360)
	output result: Direction
	if angle >= 0 and angle < 90 {
		result << North
	} else if angle >= 90 and angle < 180 {
		result << East
	} else if angle >= 180 and angle < 270 {
		result << South
	} else {
		result << West
	}
}

pure getDirection {
	input angle: NumberRange(0, 360)
	output result: Direction
	result <- {
		if angle >= 0 and angle < 90 { North }
		else if angle >= 90 and angle < 180 { East }
		else if angle >= 180 and angle < 270 { South }
		else { West }
	}
}

// ========== ERROR HANDLING ==============

// Calling GET on a type without any further inputs returns all instances of that type
// the type here is User(GET) -> Result<[User], Error>
case User(GET) {
	// First item specifies the matched variant, and the second a name which its content is bound to.
	Ok users {
		// users here contains the list of all users
	}
	Err error {
		// error contains an error type with additional information about what went wrong.
	}
}

// Implicitly combining errors
impure getUsersAndSubscriptions {
	output users: [User]
	output subscriptions: [Subscription]

	users <- User(GET) // Result<[User], Error>
	subscriptions <- Subscription(GET)

	// Since User and Subscription can return an error, getUsersAndSubscriptions type will actually
	// become () -> Result<(users: [User], subscriptions: [Subscription]), Error>
}

// Functions and such

impure startNewSubscriptionPeriod {
	requires_context Authenticated
	input subscription: Subscription
	input usage: DataUsagePeriod

	let dlf = dataLeftOver(subscription, usage)
	SubscriptionPeriod(CREATE, dlf, current_user)
}